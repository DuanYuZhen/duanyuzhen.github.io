<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>莲青儿的博客</title>
  <subtitle>Hexo博客搭建</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-04-11T07:13:40.968Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>莲青儿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用nvm安装和多个Node.js版本之间切换</title>
    <link href="http://yoursite.com/2017/04/07/nvm/"/>
    <id>http://yoursite.com/2017/04/07/nvm/</id>
    <published>2017-04-07T05:00:15.000Z</published>
    <updated>2017-04-11T07:13:40.968Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h2><p>nvm全称是Node Version Manager</p>
<a id="more"></a>
<h2 id="nvm配置步骤"><a href="#nvm配置步骤" class="headerlink" title="nvm配置步骤"></a>nvm配置步骤</h2><p>去以下网站下载nvm windows版本:<br><a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="external">https://github.com/coreybutler/nvm-windows/releases</a></p>
<p>用nvm install 6.1.0 下载相应版本的node.js</p>
<p>在cmd中做如下操作来保证node可以用：<br>1、 输入nvm list 查看当前所有安装好的nodejs版本<br>2、 输入 nvm use 4.4.3 来使nodejs4.4.3版本为当前使用状态<br>3、再次输入nvm list后会看到4.4.3后面多了一个标记使用的文字提醒</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;nvm&quot;&gt;&lt;a href=&quot;#nvm&quot; class=&quot;headerlink&quot; title=&quot;nvm&quot;&gt;&lt;/a&gt;nvm&lt;/h2&gt;&lt;p&gt;nvm全称是Node Version Manager&lt;/p&gt;
    
    </summary>
    
      <category term="nvm和Node.js版本切换" scheme="http://yoursite.com/categories/nvm%E5%92%8CNode-js%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2/"/>
    
    
  </entry>
  
  <entry>
    <title>TypeScript</title>
    <link href="http://yoursite.com/2017/04/06/TypeScript/"/>
    <id>http://yoursite.com/2017/04/06/TypeScript/</id>
    <published>2017-04-06T15:11:15.000Z</published>
    <updated>2017-04-11T07:26:55.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>1.TypeScript是JavaScript的超集，而且本质上向这个语言添加了基于类的面向对象编程。可以编译成javascript。<br>2.TypeScript可以在任何浏览器、任何计算机和任何操作系统上运行，并且是开源的。<br><a id="more"></a><br>3.TypeScript扩展了JavaScript的语法，所以任何现有的JavaScript程序可以不加改变的在TypeScript下工作。<br>4.并且TypeScript增加了对ECMAScript 6的语法的支持，符合Javascript的发展方向。eg：直接定义一个类。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;1.TypeScript是JavaScript的超集，而且本质上向这个语言添加了基于类的面向对象编程。可以编译成javascript。&lt;br&gt;2.TypeScript可以在任何浏览器、任何计算机和任何操作系统上运行，并且是开源的。&lt;br&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="http://yoursite.com/categories/TypeScript/"/>
    
    
  </entry>
  
  <entry>
    <title>Angular1 和 Angular2 区别</title>
    <link href="http://yoursite.com/2017/04/06/angular1%E5%92%8C2%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2017/04/06/angular1和2区别/</id>
    <published>2017-04-06T06:00:15.000Z</published>
    <updated>2017-04-11T07:14:02.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li>Angular2不是从Angular1升级过来的，Angular2是重写的，所以他们之间的差别比较大，不是你用过1就能直接上手2的，计划可以认为是一个新的框架。</li>
</ol>
<a id="more"></a>
<ol>
<li>Angular2最大的一个变更，就是框架整体上的components基于TypeScript。默认用TypeScript写。所以angular1和angular2从设定之初就是不一样的。并且TypeScript的语法和Java或者C#非常类似，因此对于从后端转过来的开发者来说，学习这门语言是没有难度的。</li>
<li>Angular1.x在设计之初主要是针对pc端的，对移动端支持较少（当然也有其他一些衍生框架如ionic），而Angular2是设计包含移动端的。</li>
<li>Angular 1的核心概念是$scope，但是angular2中没有$scope，angular2使用zone.js来记录监测变化。</li>
<li>Angular 1 中的控制器在angular2中不再使用，也可以说控制器在angular2中被‘Component’组件所替代：</li>
</ol>
<p><img src="http://duanyuzhen.github.io/images/imgs/6.png" alt="事件回调"></p>
<pre><code>////Angular 1.x using Controller and $scope.........
var myApp = angular
 .module(&quot;myModule&quot;, []) 
.controller(&quot;productController&quot;, function($scope) {
var prods = { name: &quot;Prod1&quot;, quantity: 1 }; 
$scope.products = prods;
});

///Angular 2 Components using TypeScript........
import { Component } from ‘angular 2/core’;
@Component({
 selector: ‘prodsdata’,
 template: `
 &lt;h3&gt;{{techncalDiary}}&lt;/h3&gt; `
})
export class ProductComponent {
 prods = { name: ‘Prod1’, quantity: 1 };
}
</code></pre><p>6.Angular 2中, 指令的结构、用法作了一些调整，比如1中的ng-repeat被*ngFor替代</p>
<pre><code>///Angular 1.x structural directives:........
&lt;ul&gt;
    &lt;li ng-repeat=&quot;item in items&quot;&gt;
        {{item.name}}
    &lt;/li&gt;
&lt;/ul&gt;

///Angular 2 structural directives:.............
&lt;ul&gt;
    &lt;li *ngFor=&quot;#item of items&quot;&gt;
        {{item.name}}
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>7.双向数据绑定: [(ngModel)]的写法替换了ng-model</p>
<pre><code>///Angular 1.x, two-way data binding using &apos;ng-model&apos;..........
&lt;input ng-model=&quot;technology.name&quot;&gt;&lt;/input&gt; 

/////In Angular 2,two-way data binding using &apos;[(ngModel)]&apos;..........
&lt;input [(ngModel)]=&quot;http://technology.name&quot;&gt;&lt;/input&gt;
</code></pre><p>8.Angular 2主要的性能优化改进是使用了分层依赖注入系统.这些优化改进是angular2的速度比angular1的速度提高很多</p>
<p>9.Angular 2的大小是20kb左右，相对于angular1体积减少很多</p>
<p>10.在Angular2.x中，因为其是基于ES6来开发的，所以会有很多第三方依赖。由于很多浏览器还不支持ES6，所以Angular2通过一些第三方依赖，将基于ES6的语法文件解析成ES5语法文件，使浏览器能支持Angular2.X。所以只要支持ES5的浏览器就能用。  </p>
<p>从IE10开始支持ES5，所以IE10以上以及其他主流的浏览器都支持。在PC端开发的时候，要注意IE9以下的兼容，移动端开发时，可以比较放心。</p>
<h2 id="实现双向数据绑定"><a href="#实现双向数据绑定" class="headerlink" title="实现双向数据绑定"></a>实现双向数据绑定</h2><p><strong>Angular1</strong><br>通过视图可以改变控制器中变量的值<br>通过控制器中的变量可以更改视图的显示值</p>
<pre><code>&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt;
    输入: &lt;input ng-model=&quot;name&quot;&gt;
    &lt;h1&gt;你输入了: {{name}}&lt;/h1&gt;
&lt;/div&gt;

&lt;script&gt;
var app = angular.module(&apos;myApp&apos;, []);
app.controller(&apos;myCtrl&apos;, function($scope) {
    $scope.name = &quot;test&quot;;
});
&lt;/script&gt;
</code></pre><p>每绑定一个数据eg：ng-model，都会添加一个新的监视器，大量的监视器会拖慢性能。  </p>
<pre><code>监视器：    
$scope.$watch(&apos;name&apos;, function(newValue, oldValue) {  
      //update the DOM with newValue  
});

angular1中会因某些指令（eg：ng-click）而运行函数$scope.$apply()，然后调用$rootScope.$digest()来触发一轮$digest循环，在$digest循环的时候，监视器被触发。监视器会检查$scope模型中的name数据是否发生了变化。当name的值发生变化的时候，回调函数会被调用。
</code></pre><p><em>缺点</em>：</p>
<ol>
<li>angular1每绑定一个数据，都会添加一个新的监视器，大量的监视器会拖慢性能。</li>
<li>$scope在回调的场景下，监视器是无法感知$scope上的变化，因此经常需要开发者手动调用$apply()方法，eg：原生js事件回调等等,如下图：<br><img src="http://duanyuzhen.github.io/images/imgs/5.png" alt="事件回调"></li>
</ol>
<p><strong>Angular2</strong></p>
<p>删除了$scope的概念，另外引入了zone.js文件，zone.js来实现数据的双向绑定。<br>不会出现Angular1的那种缺点，因为zone.js文件的理论是将javascript原生文件的监听事件函数给覆盖了。所以在写原生js回调事件的时候，也会监听到数据的变化。</p>
<p>简单而言就是：angular1是将js外面包装了一层实现框架，而angular2中的zone.js直接将js的某些方法重写了。所以angular2提升了性能。</p>
<h2 id="改进依赖注入"><a href="#改进依赖注入" class="headerlink" title="改进依赖注入"></a>改进依赖注入</h2><p><strong>Angular 1 的多重依赖注入机制</strong></p>
<p>Angular 1支持三种定义依赖注入的方式：</p>
<p>1.数组标注：最常用且推荐的方式。</p>
<pre><code>myApp.controller(&apos;smallCatCtrl&apos;, [&apos;$scope&apos;, function($scope){  
    $scope.sayCat = function(){  
        alert(&apos;I Love Circle!&apos;);  
    }  
}]);  
</code></pre><p>2.$inject属性标注：通过方法$inject声明依赖的组件</p>
<pre><code>var MyController = function($scope, myService) {  
  // ...  
}  
MyController.$inject = [&apos;$scope&apos;, &apos;myService&apos;];  
myApp.controller(&apos;MyController&apos;, MyController);  
</code></pre><p>3.隐式标注：最简易，Angular会通过方法的参数名，推断找到依赖的组件</p>
<pre><code>myApp.controller(&apos;smallCatCtrl&apos;, function($scope){  
    $scope.sayCat = function(){  
        alert(&apos;I Love Circle!&apos;);  
    }  
});
</code></pre><p><strong>Angular 2 将会作出怎样的该进</strong></p>
<p>在 Angular 2 中有且仅有一种依赖注入机制： 在构造函数中通过类型注入。</p>
<pre><code>constructor(keyUtils: KeyboardUtils) {
    this.keyUtils = keyUtils;
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Angular2不是从Angular1升级过来的，Angular2是重写的，所以他们之间的差别比较大，不是你用过1就能直接上手2的，计划可以认为是一个新的框架。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Angular1和Angular2区别" scheme="http://yoursite.com/categories/Angular1%E5%92%8CAngular2%E5%8C%BA%E5%88%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>AngularJS2.0旧版</title>
    <link href="http://yoursite.com/2017/03/31/angular2.0_2/"/>
    <id>http://yoursite.com/2017/03/31/angular2.0_2/</id>
    <published>2017-03-31T01:50:15.000Z</published>
    <updated>2017-04-11T07:13:06.316Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文的内容已经过期了，Angular2现在已经完全基于TypeScript开发了</strong></p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p><em>疑问：Angular不就是一个框架么，搞什么环境搭建，不是像angular1那样引入一个angular.js就搞定了么？</em></p>
<a id="more"></a>
<ol>
<li>Angular2.x与Angular1.x是雷锋与雷峰塔的区别</li>
<li>Angular2.x是不兼容Angular1.x的，所在在框架的构造上，它们是完全不同的</li>
<li>在Angular2.x中，因为其是基于ES6来开发的，所以会有很多第三方依赖。由于很多浏览器还不支持ES6，所以Angular2引入了很多polyfill或者shim, 导致我们引入了第三方依赖。<br>通俗的讲：就是通过一些第三方依赖，将基于ES6的语法文件解析成ES5语法文件，使浏览器能支持Angular2.X。</li>
</ol>
<h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Angular2 Hello world&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;

    &lt;sample-app&gt;正在加载中...&lt;/sample-app&gt;

    &lt;!-- ES6-related imports --&gt;
    &lt;script src=&quot;lib/traceur-runtime.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;lib/es6-module-loader-sans-promises.src.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;lib/extension-register.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;lib/reflect.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
    register(System);
    &lt;/script&gt;

    &lt;!-- Angular2-related imports --&gt;
    &lt;script src=&quot;lib/zone.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;lib/long-stack-trace-zone.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;lib/angular2.js&quot;&gt;&lt;/script&gt;

    &lt;!-- Application bootstrap logic --&gt;
    &lt;script&gt;
    System.import(&apos;app&apos;)
        .then(function(app) {
            app.main();
        }, function(e) {
            console.error(&apos;Boostrap angular2 failed!&apos;, e);
        });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

运行Angular2不容易
</code></pre><p><strong>官方的文档，不知道写的什么，你按照那个，很难跑起来。而且和Angular2的版本还不同步，因为它在不断更新中，官方文档会相对比较旧点。</strong></p>
<hr>
<p><strong>现在我们关注的是：这些乱七八糟的js文件从哪里来的？ 我应该从哪里找到这些玩意。</strong></p>
<ol>
<li>gulp</li>
</ol>
<p>首先先解释一下gulp。<br>按照官方的说法，它是基于数据流的构建系统，主要增强工作流程的自动化。<br>通过gulp，我们可以自动化这些过程，一个命令，就全部搞定了  </p>
<p>详情见<a href="http://www.w3ctech.com/topic/134" target="_blank" rel="external">gulp开发教程</a><br>或者<a href="http://www.gulpjs.com.cn/" target="_blank" rel="external">gulp的中文站点</a>都是不错的文章</p>
<p>要使用gulp，首先得安装gulp。gulp 是基于node.js开发的，必须先配置好node.js环境，然后才能安装gulp。只需要：<br>    npm install gulp -g</p>
<p>也就是说，我们得有一个gulpfile.js，这个文件定义了我们需要完成的任务，然后通过执行gulp命令即可。</p>
<p>gulpfile.js定义的任务都是靠gulp.task这个函数来完成的。如下：<br>    ‘use strict’;</p>
<pre><code>var gulp = require(&apos;gulp&apos;),
    del = require(&apos;del&apos;),
    plumber = require(&apos;gulp-plumber&apos;),
    rename = require(&apos;gulp-rename&apos;),
    traceur = require(&apos;gulp-traceur&apos;);


var connect = require(&apos;gulp-connect&apos;),
    open = require(&apos;gulp-open&apos;),
    port = 3456;

var PATHS = {
    src: {
        js: &apos;src/**/*.js&apos;,
        html: &apos;src/**/*.html&apos;
    },
    lib: [
        &apos;node_modules/gulp-traceur/node_modules/traceur/bin/traceur-runtime.js&apos;,
        &apos;node_modules/es6-module-loader/dist/es6-module-loader-sans-promises.src.js&apos;,
        &apos;node_modules/systemjs/lib/extension-register.js&apos;,
        &apos;node_modules/angular2/node_modules/zone.js/dist/zone.js&apos;,
        &apos;node_modules/angular2/node_modules/zone.js/dist/long-stack-trace-zone.js&apos;,
        &apos;node_modules/reflect-metadata/Reflect.js&apos;,
        &apos;node_modules/reflect-metadata/Reflect.js.map&apos;,
    ]
};


gulp.task(&apos;watch&apos;, function() {
    gulp.watch(PATHS.src.js, [&apos;js&apos;]);
    gulp.watch(PATHS.src.html, [&apos;html&apos;]);
});

gulp.task(&apos;js&apos;, function() {
    return gulp.src(PATHS.src.js)
        .pipe(rename({
            extname: &apos;&apos;
        })) //hack, see: https://github.com/sindresorhus/gulp-traceur/issues/54
        .pipe(plumber())
        .pipe(traceur({
            modules: &apos;instantiate&apos;,
            moduleName: true,
            annotations: true,
            types: true,
            memberVariables: true
        }))
        .pipe(rename({
            extname: &apos;.js&apos;
        })) //hack, see: https://github.com/sindresorhus/gulp-traceur/issues/54
        .pipe(gulp.dest(&apos;dist&apos;));
});

gulp.task(&apos;html&apos;, function() {
    return gulp.src(PATHS.src.html)
        .pipe(gulp.dest(&apos;dist&apos;));
});

gulp.task(&apos;angular2&apos;, function() {

    var buildConfig = {
        paths: {
            &quot;angular2/*&quot;: &quot;node_modules/angular2/es6/prod/*.es6&quot;,
            &quot;rx&quot;: &quot;node_modules/angular2/node_modules/rx/dist/rx.js&quot;
        },
        meta: {
            // auto-detection fails to detect properly here - https://github.com/systemjs/builder/issues/123
            &apos;rx&apos;: {
                format: &apos;cjs&apos;
            }
        }
    };

    var Builder = require(&apos;systemjs-builder&apos;);
    var builder = new Builder(buildConfig);

    return builder.build(&apos;angular2/angular2&apos;, &apos;dist/lib/angular2.js&apos;, {});
});

gulp.task(&apos;libs&apos;, [&apos;angular2&apos;], function() {
    var size = require(&apos;gulp-size&apos;);
    return gulp.src(PATHS.lib)
        .pipe(size({
            showFiles: true,
            gzip: true
        }))
        .pipe(gulp.dest(&apos;dist/lib&apos;));
});



gulp.task(&apos;connect&apos;, function() {
    connect.server({
        root: __dirname + &apos;/dist&apos;,
        port: port,
        livereload: true
    });
});

gulp.task(&apos;open&apos;, function() {
    var options = {
        url: &apos;http://localhost:&apos; + port,
    };
    gulp.src(&apos;./index.html&apos;)
        .pipe(open(&apos;&apos;, options));
});

gulp.task(&apos;build&apos;, [&apos;js&apos;, &apos;html&apos;])
gulp.task(&apos;default&apos;, [&apos;build&apos;, &apos;libs&apos;]);
gulp.task(&apos;serve&apos;, [&apos;connect&apos;, &apos;open&apos;]);
gulp.task(&apos;clean&apos;, function(done) {
    del([&apos;dist&apos;], done);
});
</code></pre><p>上面这个gulpfile.js文件，我简单说下它的功能：  </p>
<ol>
<li>对angular2源码进行转换，将es6代码转换为es5代码，然后合并成angular2.js，放入dest/lib目录  </li>
<li>将angular2的第三方依赖放入dest/lib目录  </li>
<li>自动监测用户写的代码，当文件发生修改时，自动将其编译为es5代码，然后放入dest目录  </li>
<li>开启一个本地服务器，让用户访问<a href="http://localhost:3456/" target="_blank" rel="external">http://localhost:3456/</a> 就可以看到页面效果  </li>
<li>删除dest目录</li>
</ol>
<p>如果我们想构建angular2及其所有的依赖文件，只需要在命令行下输入以下代码：<br>    gulp // gulp其实相当于运行gulp default, Gulp有一个默认的任务就是default</p>
<pre><code>gulp serve // 在新一个终端运行该命令，开启本地服务器
</code></pre><p>运行上面的命令，大家会看到错误。因为在Gulpfile.js中引入一些第三方插件，而且还没有看到angular2的代码。所以接下来，我们需要下载angular2代码和第三方依赖。</p>
<hr>
<p>2.下载相关文件</p>
<p>直接定义一个package.json文件，定义好所需的依赖和版本。<br>然后在目录下运行 npm install，程序就会自动下载好相关文件，并且放到 node_modules文件夹。<br>再运行gulp命令就可以正常运行了，这样运行Angular2所需要的必要条件都满足了。</p>
<p>package.json文件：</p>
<pre><code>{
  &quot;name&quot;: &quot;angular2-seed&quot;,
  &quot;version&quot;: &quot;0.2.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;author&quot;: &quot;flyingzl(flyingzl@gmail.com)&quot;,
  &quot;repository&quot;: {
    &quot;type&quot;: &quot;git&quot;,
    &quot;url&quot;:  &quot;https://github.com/flyingzl/angular2-seed&quot;
  },
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;devDependencies&quot;: {
    &quot;del&quot;: &quot;~1.1.1&quot;,
    &quot;gulp&quot;: &quot;~3.8.10&quot;,
    &quot;gulp-connect&quot;: &quot;^2.2.0&quot;,
    &quot;gulp-plumber&quot;: &quot;^1.0.0&quot;,
    &quot;gulp-open&quot;: &quot;^0.3.2&quot;,
    &quot;gulp-rename&quot;: &quot;~1.2.0&quot;,
    &quot;gulp-size&quot;: &quot;^1.2.1&quot;,
    &quot;gulp-traceur&quot;: &quot;0.17.*&quot;,
    &quot;systemjs-builder&quot;: &quot;^0.10.3&quot;,
    &quot;through2&quot;: &quot;~0.6.3&quot;
  },

  &quot;dependencies&quot;: {
    &quot;angular2&quot;: &quot;2.0.0-alpha.25&quot;,
    &quot;es6-module-loader&quot;: &quot;0.16.5&quot;,
    &quot;systemjs&quot;: &quot;0.16.7&quot;,
    &quot;reflect-metadata&quot;: &quot;0.1.0&quot;
  }
}
</code></pre><p>运行结果：<br><img src="http://duanyuzhen.github.io/images/imgs/4.png" alt="运行结果"></p>
<p><strong>其实 webpack 更佳 systemjs 不推荐</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文的内容已经过期了，Angular2现在已经完全基于TypeScript开发了&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h3&gt;&lt;p&gt;&lt;em&gt;疑问：Angular不就是一个框架么，搞什么环境搭建，不是像angular1那样引入一个angular.js就搞定了么？&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="AngularJS2.0" scheme="http://yoursite.com/categories/AngularJS2-0/"/>
    
    
  </entry>
  
  <entry>
    <title>AngularJS2.0</title>
    <link href="http://yoursite.com/2017/03/30/angular2.0_1/"/>
    <id>http://yoursite.com/2017/03/30/angular2.0_1/</id>
    <published>2017-03-30T09:00:15.000Z</published>
    <updated>2017-03-31T09:39:52.163Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Angular1-X——-gt-Angular2原因"><a href="#Angular1-X——-gt-Angular2原因" class="headerlink" title="Angular1.X——&gt;Angular2原因"></a>Angular1.X——&gt;Angular2原因</h3><h4 id="性能的限制"><a href="#性能的限制" class="headerlink" title="性能的限制"></a>性能的限制</h4><p>由于Angular1.X最初的架构限制（比如绑定和模版机制），性能的提升已经非常困难了</p>
<p>Angular1.X对WEB组件的支持都不够好</p>
<a id="more"></a>
<h4 id="移动化"><a href="#移动化" class="headerlink" title="移动化"></a>移动化</h4><p>Angular1.x没有针对移动 应用特别优化，并且缺少一些关键的特性，比如：缓存预编译的视图、触控支持等。</p>
<h4 id="简单易行"><a href="#简单易行" class="headerlink" title="简单易行"></a>简单易行</h4><p>Angular团队希望在Angular2中将复杂性 封装地更好一些，让暴露出来的概念和开发接口更简单</p>
<h4 id="ES6工具链"><a href="#ES6工具链" class="headerlink" title="ES6工具链"></a>ES6工具链</h4><p>要让Angular2应用跑起来不是件轻松的事，因为它用了太多还不被当前主流浏览器支持 的技术。所以，我们需要一个工具链</p>
<p>Angular2是面向未来的科技，要求浏览器支持ES6+，我们现在要尝试的话，需要加一些 垫片来抹平当前浏览器与ES6的差异</p>
<p>systemjs - 通用模块加载器，支持AMD、CommonJS、ES6等各种格式的JS模块加载<br>es6-module-loader - ES6模块加载器，systemjs会自动加载这个模块<br>traceur - ES6转码器，将ES6代码转换为当前浏览器支持的ES5代码。systemjs会自动加载 这个模块。</p>
<h3 id="Angular2的Hello-World（3步走）"><a href="#Angular2的Hello-World（3步走）" class="headerlink" title="Angular2的Hello World（3步走）"></a>Angular2的Hello World（3步走）</h3><p>####引入Angular2预定义类型</p>
<pre><code>// import是ES6的关键字   
// 从angular2模块库中引入了三个类型：       
// Component类、View类和bootstrap函数    

import {Component,View,bootstrap} from &quot;angular2/angular2&quot;;
</code></pre><h4 id="实现一个Angular2组件"><a href="#实现一个Angular2组件" class="headerlink" title="实现一个Angular2组件"></a>实现一个Angular2组件</h4><pre><code>// 定义类EzApp，然后给这个类添加注解@Component和@View
// @Component最重要的作用是通过selector属性
//   （值为CSS选择符），指定这个组件渲染到哪个DOM对象上。
// @View最重要的作用是通过template属性，指定渲染的模板。
@Component({selector:&quot;ez-app&quot;})
@View({template:&quot;&lt;h1&gt;Hello,Angular2&lt;/h1&gt;&quot;})
class EzApp{}
</code></pre><h4 id="渲染组件到DOM"><a href="#渲染组件到DOM" class="headerlink" title="渲染组件到DOM"></a>渲染组件到DOM</h4><pre><code>// 这个函数的作用:通知Angular2框架将EzApp组件渲染到DOM树上。
bootstrap(EzApp);
</code></pre><p><em>bootstrap ：</em>  </p>
<pre><code>// 1.以组件为核心
// Angular1.x : bootstrap是围绕DOM元素展开的，无论你使用ng-app还是手动执行bootstrap()函数，都是建立在DOM之上的。
// Angular2 ：bootstrap是围绕组件开始的，你定义一个组件，然后启动它。如果没有一个组件， 你甚至都没有办法使用Angular2

// 2.支持多种渲染引擎
// 以组件而非DOM为核心，意味着Angular2在内核隔离了对DOM的依赖 - DOM仅仅作为一种可选的渲染引擎存在：
</code></pre><p><img src="http://duanyuzhen.github.io/images/imgs/3.png" alt="解释"></p>
<p><em>Angular2解析流程</em></p>
<p><img src="http://duanyuzhen.github.io/images/imgs/2.png" alt="Angular2解析流程"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Angular1-X——-gt-Angular2原因&quot;&gt;&lt;a href=&quot;#Angular1-X——-gt-Angular2原因&quot; class=&quot;headerlink&quot; title=&quot;Angular1.X——&amp;gt;Angular2原因&quot;&gt;&lt;/a&gt;Angular1.X——&amp;gt;Angular2原因&lt;/h3&gt;&lt;h4 id=&quot;性能的限制&quot;&gt;&lt;a href=&quot;#性能的限制&quot; class=&quot;headerlink&quot; title=&quot;性能的限制&quot;&gt;&lt;/a&gt;性能的限制&lt;/h4&gt;&lt;p&gt;由于Angular1.X最初的架构限制（比如绑定和模版机制），性能的提升已经非常困难了&lt;/p&gt;
&lt;p&gt;Angular1.X对WEB组件的支持都不够好&lt;/p&gt;
    
    </summary>
    
      <category term="AngularJS2.0" scheme="http://yoursite.com/categories/AngularJS2-0/"/>
    
    
  </entry>
  
  <entry>
    <title>在线前端开发平台 Plunker</title>
    <link href="http://yoursite.com/2017/03/29/plunker/"/>
    <id>http://yoursite.com/2017/03/29/plunker/</id>
    <published>2017-03-29T04:00:15.000Z</published>
    <updated>2017-03-29T06:23:11.996Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Plunker是用来编辑和分享Web开发思路的在线社区。</p>
<a id="more"></a>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>基于 Node.js 环境运行<br>实时的代码协作<br>全功能、可定制语法编辑器<br>代码更改可即时预览效果<br>代码提示<br>可 Fork、评论和分享<br>完全开源，使用 MIT 许可<br>授权协议： MIT<br>开发语言： JavaScript<br>操作系统： 跨平台  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;Plunker是用来编辑和分享Web开发思路的在线社区。&lt;/p&gt;
    
    </summary>
    
      <category term="Plunker" scheme="http://yoursite.com/categories/Plunker/"/>
    
    
  </entry>
  
  <entry>
    <title>翻墙方法</title>
    <link href="http://yoursite.com/2017/03/27/%E7%BF%BB%E5%A2%99%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2017/03/27/翻墙方法/</id>
    <published>2017-03-27T06:27:15.000Z</published>
    <updated>2017-03-27T06:33:01.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="翻墙浏览器"><a href="#翻墙浏览器" class="headerlink" title="翻墙浏览器"></a>翻墙浏览器</h2><p>特点：简单易用，免费产品的稳定性差，无法全局翻墙，只适合临时浏览网页</p>
<a id="more"></a>
<p>1.浏览器插件</p>
<p>插件平台：google、QQ、360、猎豹、百度等webkit核心的浏览器。</p>
<p>使用说明：前往<a href="https://www.cloudlink.pro/cloudlink/web/index/index?operate=register&amp;fmcode=VcMhMq" target="_blank" rel="external">CloudLink</a>注册并登录，然后在上述浏览器安装CloudLink插件，就可以顺畅的访问国外网站了。</p>
<p>Tips:CloudLink是一款付费产品，每天会有10-60分钟的随机免费体验时长。</p>
<p>2.天行浏览器</p>
<p><a href="http://zhangge.net/4586.html#button_file" target="_blank" rel="external">下载地址</a></p>
<h2 id="VPN翻墙"><a href="#VPN翻墙" class="headerlink" title="VPN翻墙"></a>VPN翻墙</h2><p>特点：长期稳定，能满足各种翻墙需求，可能需要支付小额费用。</p>
<p>VPN指虚拟专用网络</p>
<p>VPN翻墙就是通过建立一个国外的虚拟专用网络，绕过中国国家防火墙(GFW——&gt;great firewall)来访问国外的网站。</p>
<p><strong>建立国外的虚拟专用网络:</strong></p>
<p>用他人搭建好的VPN服务器(IP)<br>购买国外的VPS自己搭建</p>
<p>几个国内稳定、优秀的VPN服务可以按需使用：</p>
<p><img src="http://duanyuzhen.github.io/images/imgs/1.png" alt="VPN"></p>
<p>VPN服务都会提供专用的VPN客户端，基本都是傻瓜式的配置，也存在没有配套客户端的VPN，参考一下VPN设置教程——&gt;<a href="http://zhangge.net/5009.html" target="_blank" rel="external">http://zhangge.net/5009.html</a></p>
<p>对于各种VPN的详解，请查阅<a href="http://zhangge.net/4586.html" target="_blank" rel="external">张戈博客</a></p>
<h2 id="自由门翻墙"><a href="#自由门翻墙" class="headerlink" title="自由门翻墙"></a>自由门翻墙</h2><p>自由门（Freegate）是动态网公司开发的一种翻墙软件，用来突破国家防火墙 用来浏览被屏蔽的网站或者收发邮件。因为国家防火墙不断加强封锁，所以该软件也不断升级突破国家防火墙。</p>
<h2 id="安全隐患"><a href="#安全隐患" class="headerlink" title="安全隐患"></a>安全隐患</h2><p>网络数据是从他人服务器经过，有安全隐患。建议不要进行个人隐私操作，比如网银支付宝等。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;翻墙浏览器&quot;&gt;&lt;a href=&quot;#翻墙浏览器&quot; class=&quot;headerlink&quot; title=&quot;翻墙浏览器&quot;&gt;&lt;/a&gt;翻墙浏览器&lt;/h2&gt;&lt;p&gt;特点：简单易用，免费产品的稳定性差，无法全局翻墙，只适合临时浏览网页&lt;/p&gt;
    
    </summary>
    
      <category term="翻墙" scheme="http://yoursite.com/categories/%E7%BF%BB%E5%A2%99/"/>
    
    
  </entry>
  
  <entry>
    <title>跨域问题_1</title>
    <link href="http://yoursite.com/2017/03/24/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98_1/"/>
    <id>http://yoursite.com/2017/03/24/跨域问题_1/</id>
    <published>2017-03-24T06:27:15.000Z</published>
    <updated>2017-03-27T07:03:15.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="域-Domain"><a href="#域-Domain" class="headerlink" title="域(Domain)"></a>域(Domain)</h2><h3 id="顶级域名"><a href="#顶级域名" class="headerlink" title="顶级域名"></a>顶级域名</h3><p>1.国家顶级域名：<br>200多个国家都按照ISO3166国家代码分配了顶级域名，<br>例如中国是.cn，美国是.us，日本是.jp等；<br>2.国际顶级域名：<br>工商企业的 .Com，表示网络提供商的.net，表示非盈利组织的.org。</p>
<a id="more"></a>
<p>注意：<br>大多数域名争议都发生在com的顶级域名下，因为多数公司上网的目的都是为了赢利。<br>国际组织经过广泛协商，在原来三个国际通用顶级域名的基础上，<br>新增加了7个国际通用顶级域名：<br>.firm（公司企业）、<br>.store（销售公司或企业）、<br>.Web（突出WWW活动的单位）、<br>.arts（突出文化、娱乐活动的单位）、<br>.rec (突出消遣、娱乐活动的单位)、<br>.info (提供信息服务的单位)、<br>.nom(个人)，<br>并在世界范围内选择新的注册机构来受理域名注册申请。</p>
<p>3.我国的顶级域名<br>我国在国际互联网络信息中心(Inter NIC)正式注册并运行的顶级域名是.cn,这也是我国的一级域名。</p>
<h3 id="多级域名"><a href="#多级域名" class="headerlink" title="多级域名"></a>多级域名</h3><p>*凡顶级域名前加前缀的都是该顶级域名的子域名，而子域名根据技术的多少分为二级子域名，三级子域名以及多级子域名。</p>
<ol>
<li><p>二级域名<br>在国际顶级域名下，它是指域名注册人的网上名称，<br>例如 “.ibm”，”.yahoo”，”.microsoft”等；<br>在国家顶级域名下，它是表示注册企业类别的符号，<br>例如”.com”，”.edu”，”.gov”，”.net”等。</p>
</li>
<li><p>我国的二级域名<br>在顶级域名之下，我国的二级域名又分为类别域名和行政区域名两类。<br><em>类别域名共6个，包括:<br>用于科研机构的.ac；<br>用于工商金融企业的.com；<br>用于教育机构的.edu；<br>用于政府部门的.gov；<br>用于互联网络信息中心和运行中心的.net；<br>用于非盈利组织的.org。  
</em>行政区域名有34个，分别对应于我国各省、自治区和直辖市。</p>
</li>
<li><p>三级域名<br>三级域名用字母（a～z）、数字（0～9）和连接符（－）组成，<br>各级域名之间用实点（.）连接，三级域名的长度不能超过20个字符。<br>如无特殊原因，采用申请人的英文名(或者缩写)或者汉语拼音名(或者缩写)作为三级域名，以保持域名的清晰性和简洁性。</p>
<p><strong>跨域：</strong><br>1.解释：<br>javascript出于安全方面的考虑，不允许跨域调用其他页面的对象<br>由于JavaScript同源策略的限制，出现跨域问题  </p>
</li>
</ol>
<p>2.跨域的出现与否：<br>（1）没有跨域问题：同一域名，不同文件夹<br>（2）跨域：<br>—— 同一域名，端口不同<br>—— 同一域名，协议不同<br>—— 域名和域名对应ip<br>—— 主域相同，子域不同<br><a href="http://www.a.com/a.js" target="_blank" rel="external">http://www.a.com/a.js</a><br><a href="http://script.a.com/b.js" target="_blank" rel="external">http://script.a.com/b.js</a><br>—— 同一域名，不同二级域名（同上）<br>——cookie这种情况下也不允许访问<br><a href="http://www.a.com/a.js" target="_blank" rel="external">http://www.a.com/a.js</a><br><a href="http://a.com/b.js" target="_blank" rel="external">http://a.com/b.js</a><br>—— 不同域名<br>（3）注意：<br>如果是协议、端口造成跨域问题，前台是无能为力的<br>在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。<br>“URL的首部”指window.location.protocol(协议) +window.location.host(域名:包括ip和端口)<br>即：Domains, protocols and ports must match”  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;域-Domain&quot;&gt;&lt;a href=&quot;#域-Domain&quot; class=&quot;headerlink&quot; title=&quot;域(Domain)&quot;&gt;&lt;/a&gt;域(Domain)&lt;/h2&gt;&lt;h3 id=&quot;顶级域名&quot;&gt;&lt;a href=&quot;#顶级域名&quot; class=&quot;headerlink&quot; title=&quot;顶级域名&quot;&gt;&lt;/a&gt;顶级域名&lt;/h3&gt;&lt;p&gt;1.国家顶级域名：&lt;br&gt;200多个国家都按照ISO3166国家代码分配了顶级域名，&lt;br&gt;例如中国是.cn，美国是.us，日本是.jp等；&lt;br&gt;2.国际顶级域名：&lt;br&gt;工商企业的 .Com，表示网络提供商的.net，表示非盈利组织的.org。&lt;/p&gt;
    
    </summary>
    
      <category term="跨域问题" scheme="http://yoursite.com/categories/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>jQuery中ajax的4种常用请求方式</title>
    <link href="http://yoursite.com/2017/03/24/jQuery%E4%B8%ADajax%E7%9A%844%E7%A7%8D%E5%B8%B8%E7%94%A8%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/03/24/jQuery中ajax的4种常用请求方式/</id>
    <published>2017-03-24T03:27:15.000Z</published>
    <updated>2017-03-27T07:05:09.958Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/*jQuery中ajax的4种常用请求方式：*/
// 1----------------------------  
// $.ajax()返回其创建的 XMLHttpRequest 对象。  
// $.ajax() 只有一个参数：参数 key/value 对象，包含各配置及回调函数信息。  
// 如果你指定了 dataType 选项，请确保服务器返回正确的 MIME 信息，(如 xml 返回 &quot;text/xml&quot;)
</code></pre><a id="more"></a>
<pre><code> // $.ajax({
 //        type: &quot;post&quot;,
 //        dataType: &quot;html&quot;,//服务器返回的文本格式
 //        url: &apos;/Resources/GetList.ashx&apos;,
 //        data: dataurl,//请求的数据
 //        success: function (data) {
 //            if (data != &quot;&quot;) {
 //                $(&quot;#pager&quot;).pager({
                        pagenumber: pagenumber, 
                        pagecount: data.split(&quot;&quot;)[1], 
                        buttonClickCallback: PageClick 
                    });                 
                   $(&quot;#anhtml&quot;).html(data.split(&quot;&quot;)[0]);
 //            }
 //        }
 //    });



// 2----------------------------  
// 通过远程 HTTP GET 请求载入信息。  
// 简单的 GET 请求功能以取代复杂$.ajax 请求成功时可调用回调函数。
   如果需要在出错时执行函数，请使用 $.ajax。  

// $.get(
//     &quot;../saveUser.action&quot;, //请求路径
//     { name: &quot;John&quot;, time: &quot;2pm&quot; },//请求数据
//     function(data,status){//响应的数据、响应的状态
//         alert(&quot;Data Loaded: &quot; + data);//数据处理
//     }
// ); 




// 3.-----------------------------  
// 通过远程 HTTP POST 请求载入信息。  
// 简单的 POST 请求功能以取代复杂 $.ajax 。
   请求成功时可调用回调函数。如果需要在出错时执行函数，请使用 $.ajax。  

//  $.post(
//     &quot;/Resources/addfriend.ashx&quot;, 
//     { &quot;fid&quot;: fids, &quot;fname&quot;: fnames, &quot;tuid&quot;: tuids, &quot;tuname&quot;: tunames }, 
//     function (data,status) {
//         if (data == &quot;ok&quot;) {
//             alert(&quot;添加成功！&quot;);
//         }
//     }
// );


// 4------------------------------  
// 通过 HTTP GET 请求载入 JSON 数据。  

$.getJSON(
    &quot;http://10.2.1.14:9000/screenlog/&quot;,
    function(data){//data是JSON格式的响应数据
      console.log(data);
    }
);
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;/*jQuery中ajax的4种常用请求方式：*/
// 1----------------------------  
// $.ajax()返回其创建的 XMLHttpRequest 对象。  
// $.ajax() 只有一个参数：参数 key/value 对象，包含各配置及回调函数信息。  
// 如果你指定了 dataType 选项，请确保服务器返回正确的 MIME 信息，(如 xml 返回 &amp;quot;text/xml&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="前端请求方式" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>面试——中高级JS程序员</title>
    <link href="http://yoursite.com/2017/03/24/%E9%9D%A2%E8%AF%95_%E4%B8%AD%E9%AB%98%E7%BA%A7JS%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    <id>http://yoursite.com/2017/03/24/面试_中高级JS程序员/</id>
    <published>2017-03-24T01:27:15.000Z</published>
    <updated>2017-03-27T07:07:55.617Z</updated>
    
    <content type="html"><![CDATA[<p> 1.考察对JS中同步和异步代码的区别、<br>   变量作用域、<br>   闭包等概念有正确的理解</p>
<a id="more"></a>
<pre><code>for (var i = 0; i &lt; 5; i++) {
    setTimeout(function() {
        console.log(new Date, i);
    }, 1000);
}
console.log(new Date, i);
// 答案：输出
// 2017-03-18T00:43:45.873Z 5    
// 2017-03-18T00:43:46.866Z 5
// 2017-03-18T00:43:46.868Z 5
// 2017-03-18T00:43:46.868Z 5
// 2017-03-18T00:43:46.868Z 5
// 2017-03-18T00:43:46.868Z 5

// 时间：
// 第1个5直接输出  是最后那个console.log()输出的。
// 1秒之后，输出5个5 是for里的console.log()。


2.追问：期望代码的输出变成：5 -&gt; 0,1,2,3,4
        第1个5直接输出
        1秒之后，输出5个数：0，1，2，3，4



解决：两种合格方式、一种不合格方式


// （1）闭包
for (var i = 0; i &lt; 5; i++) {
    (function(j) {  // j = i
        setTimeout(function() {
            console.log(new Date, j);
        }, 1000);
    })(i);
}
console.log(new Date, i);


// （2）利用 JS 中基本类型（Primitive Type）的参数传递是按值传递（Pass by Value）的特征
var output = function (i) {
    setTimeout(function() {
        console.log(new Date, i);
    }, 1000);
};
for (var i = 0; i &lt; 5; i++) {
    output(i);  // 这里传过去的 i 值被复制了
}
console.log(new Date, i);


// （3）使用 ES6 块级作用域（Block Scope）中的 let 替代了 var
// 但是：代码在实际运行时会报错，i只存在于循环内部
for (let i = 0; i &lt; 5; i++) {
    setTimeout(function() {
        console.log(new Date, i);
    }, 1000);
}
console.log(new Date, i);





3.追问：期望代码的输出变成 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
</code></pre><p>// 熟悉和掌握异步操作的流程控制是成为合格开发者的基本功</p>
<pre><code>解决：


// （1）粗暴有效的方法，但不能加分
// 面试官真正想考察的是候选人是否具备某种能力和素质，因为在现代的前端开发中，处理异步的代码随处可见，熟悉和掌握异步操作的流程控制是成为合格开发者的基本功
for (var i = 0; i &lt; 5; i++) {
    (function(j) {
        setTimeout(function() {
            console.log(new Date, j);
        }, 1000 * j);  // 这里修改 0~4 的定时器时间
    })(i);
}
setTimeout(function() { // 这里增加定时器，超时设置为 5 秒
    console.log(new Date, i);
}, 1000 * i);


// （2）ES6
//--------给出基于 Promise 的解决方案，Promise 是 ES6 中的新特性
const tasks = [];
for (var i = 0; i &lt; 5; i++) {   // 这里 i 的声明不能改成 let，如果要改该怎么做？
    ((j) =&gt; {
        tasks.push(new Promise((resolve) =&gt; {
            setTimeout(() =&gt; {
                console.log(new Date, j);
                resolve();  // 这里一定要 resolve，否则代码不会按预期 work
            }, 1000 * j);   // 定时器的超时时间逐步增加
        }));
    })(i);
}

Promise.all(tasks).then(() =&gt; {
    setTimeout(() =&gt; {
        console.log(new Date, i);
    }, 1000);   // 注意这里只需要把超时设置为 1 秒
});


//-------而代码要更简捷，代码阅读时的颗粒度更小，模块化更好
const tasks = []; // 这里存放异步操作的 Promise
const output = (i) =&gt; new Promise((resolve) =&gt; {
    setTimeout(() =&gt; {
        console.log(new Date, i);
        resolve();
    }, 1000 * i);
});

// 生成全部的异步操作
for (var i = 0; i &lt; 5; i++) {
    tasks.push(output(i));
}

// 异步操作完成之后，输出最后的 i
Promise.all(tasks).then(() =&gt; {
    setTimeout(() =&gt; {
        console.log(new Date, i);
    }, 1000);
});

// （3）ES7
// 使用 ES7 中的 async await 特性来让这段代码变的更简洁
// 模拟其他语言中的 sleep，实际上可以是任何异步操作
const sleep = (timeountMS) =&gt; new Promise((resolve) =&gt; {
    setTimeout(resolve, timeountMS);
});

(async () =&gt; {  // 声明即执行的 async 函数表达式
    for (var i = 0; i &lt; 5; i++) {
        await sleep(1000);
        console.log(new Date, i);
    }

    await sleep(1000);
    console.log(new Date, i);
})();
</code></pre><p>多数面试官在决定聘用某个候选人之前还需要考察另外一项重要能力，即技术自驱力。<br>直白的说就是：像有内部的马达在驱动他，用漂亮的方式解决工程领域的问题，不断的跟随业务和技术变得越来越牛逼<br>对于前端工程师的成长期许：扎实的语言基础、与时俱进的能力、强大技术自驱力。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 1.考察对JS中同步和异步代码的区别、&lt;br&gt;   变量作用域、&lt;br&gt;   闭包等概念有正确的理解&lt;/p&gt;
    
    </summary>
    
      <category term="Javascript面试" scheme="http://yoursite.com/categories/Javascript%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Markdown简介</title>
    <link href="http://yoursite.com/2017/03/23/Markdown_Note/"/>
    <id>http://yoursite.com/2017/03/23/Markdown_Note/</id>
    <published>2017-03-23T02:27:15.000Z</published>
    <updated>2017-03-27T06:36:17.612Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>markdown是标记语言，通过标记语法使普通文本具有一定格式。</p>
<a id="more"></a>
<p>具有衍生版本（eg：表格、脚本、内嵌HTML），它们能让markdown转换成更多的格式，例如：LaTeX、Docbook</p>
<p>markdown中增强版中比较有名的是Markdown Extra、MultiMarkdown、Maruku等。这些衍生版本要么基于工具，eg：Pandoc；要么基于GitHub和Wikipedia，在语法上基本兼容。</p>
<h3 id="markdown编辑器推荐"><a href="#markdown编辑器推荐" class="headerlink" title="markdown编辑器推荐"></a>markdown编辑器推荐</h3><h4 id="在线版"><a href="#在线版" class="headerlink" title="在线版"></a>在线版</h4><p>dillinger（来自国外、不够稳定）——支持md、html、pdf文件导出<br>StackEdit——对中文支持不好<br>MaHua——小众软件推荐、界面有点简陋<br>简书（博客平台）——需要注册帐号后编辑、每几秒钟便会自动存入一个备份、直接从本地拖入照片生成链接<br>马克飞象——付费软件</p>
<h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><p>MarkdownPad——左右栏分割，可以实时看到HTML格式的Markdown文档<br>MarkPad——开源的<br>Smark——开源软件<br>Miu——模仿mou、小众推荐、官网无法打开 百度云下载、界面美观、功能不成熟</p>
<h4 id="OSX（Mac）"><a href="#OSX（Mac）" class="headerlink" title="OSX（Mac）"></a>OSX（Mac）</h4><p>Mou——Mac下杰出的编辑器、提供语法高亮、在线预览、同步滚动、全屏模式、自动匹配、允许自定义主题、支持CSS HTML PDF导出<br>MacDown——开源且免费<br>Ulysses——付费的、支持OSX、iPad、堪称佼佼者<br>iA Writer——未优化中文显示<br>MWeb——专业、UI漂亮、主题可选、支持发布到wp、blogger、tumblr等多个博客  </p>
<h4 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h4><p>Cmd Markdown——工具和博客平台兼顾的产品<br>小书匠编辑器——全平台覆盖<br>FarBox——免费、在本地编辑后自动同步到个人博客<br>Sublime Text 2——付费（会时不时跳出注册提醒）、界面简约大方、定位专业、需要安装插件才可以编辑markdown<br>Atom——github出的编辑器、功能强大、可以编写代码还可以编辑markdown、并且支持markdown预览（按ctrl+shift+m）<br>Retext——用python开发的、跨平台、支持导出PDF、ODT和HTML以及纯文本，支持即时预览、网页生成、语法高亮、全屏模式、可导出文件到google docs等。</p>
<h3 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h3><h4 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h4><p>第一段</p>
<p>第二段：要跟第一段之间隔一个空行，才会形成第二段    这样在前面加入空格，只会解析为一个空格（后有两个空格）<br>但是像这样，上一段话后有两个空格，并且后面文字换行写，则会解析为换行</p>
<h4 id="粗体-斜体"><a href="#粗体-斜体" class="headerlink" title="粗体 斜体"></a>粗体 斜体</h4><p><em>这是斜体</em>  <em>这也是斜体</em></p>
<p><strong>这是粗体</strong></p>
<p><strong><em>这是粗体加斜体</em></strong></p>
<h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4><p><del>删除线</del></p>
<p>该MarkdownPad不支持删除线，它也不是经典markdown中的要素</p>
<h4 id="标题（6级标题，可以省略后面的）"><a href="#标题（6级标题，可以省略后面的）" class="headerlink" title="标题（6级标题，可以省略后面的）"></a>标题（6级标题，可以省略后面的）</h4><p><strong>可以选择性地「闭合」标题，在行尾加上 #，纯粹只是美观用的。</strong><br><strong>行尾的 # 数量也不用和开头一样（行首的井字符数量决定标题的阶数）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">###### 这是H6</div><div class="line">##### 这是H5</div><div class="line">#### 这是H4</div><div class="line">### 这是H3</div><div class="line">## 这是H2</div><div class="line"># 这是H1</div></pre></td></tr></table></figure>
<p><strong>H1和H2也可以采用:文本下方添加底线。（底线的长短不要求）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">H1也可以这样</div><div class="line">=====</div><div class="line">H2也可以这样</div><div class="line">---</div></pre></td></tr></table></figure></p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><blockquote>
<p>通常在首行加上大于号来添加引用内容</p>
<blockquote>
<p>引用可以嵌套引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;# 还可以嵌套其他格式</div></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p><strong>无序列表：用+或者-或者星号来写无序列表，注意这些符号后要加空格</strong></p>
<ul>
<li>111</li>
<li>222</li>
<li>333</li>
</ul>
<hr>
<ul>
<li>aaa</li>
<li>bbb</li>
<li>ccc</li>
</ul>
<hr>
<ul>
<li>qqq</li>
<li>www</li>
<li>eee</li>
</ul>
<p><strong>有序列表：用数字接着一个英文句点,英文句点后要有空格</strong></p>
<p><strong>并且列表前面的数字是几，并不会影响显示。比如：以下两种显示相同</strong></p>
<ol>
<li>ppppppp</li>
<li>ooooooo</li>
<li>iiiiiii</li>
</ol>
<hr>
<ol>
<li>oippop</li>
<li>uoipkinl</li>
<li>hojojoko</li>
</ol>
<h4 id="内联代码"><a href="#内联代码" class="headerlink" title="内联代码???"></a>内联代码???</h4><p><strong>用单引号标记内联代码，会解析成html标签。这样，代码中的&amp; &lt; &gt;符号都会自动转义</strong></p>
<p>‘function fn(){<br>    var a = ‘7’;<br>    if(i&gt;’5’){<br>        return true;<br>    }<br>}’</p>
<h4 id="代码区域（两种方式）"><a href="#代码区域（两种方式）" class="headerlink" title="代码区域（两种方式）???"></a>代码区域（两种方式）???</h4><p><strong>第一种方式：在代码首行空4个空格</strong></p>
<pre><code>&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;HTML代码&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre><p><strong>第二种方式：github的风格——代码段的前后都用三个单引号独占一行来标记。目前主流编辑器都支持这种风格</strong></p>
<p><strong>github格式只能一行显示？？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;  </div><div class="line">	&lt;head&gt;</div><div class="line">		&lt;title&gt;HTML标题&lt;/title&gt;</div><div class="line">	&lt;/head&gt;</div><div class="line">	&lt;body&gt;HTML内容&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<h4 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h4><p><strong>用三个以上的星号、减号、底线来建立一个分隔线，独占一行</strong></p>
<hr>
<hr>
<hr>
<p><strong>可以在三个以上的星号、减号、底线里添加任意的空格</strong></p>
<hr>
<hr>
<hr>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><strong>行内式</strong></p>
<p><a href="http://www.baidu.com" target="_blank" rel="external">这是百度链接</a></p>
<p><a href="http://www.baidu.com" title="百度title" target="_blank" rel="external">这是一个带着title的百度链接</a></p>
<p>会被解释为<br><a href="http://example.com/" target="_blank" rel="external">an example</a><br><a href="http://example.com/" title="Optional Title" target="_blank" rel="external">an example</a></p>
<p><strong>非行内式（两句的顺序不限制）</strong></p>
<p><a href="http://www.baidu.com" title="百度title" target="_blank" rel="external">百度链接</a></p>
<h4 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h4><p><strong>行内式</strong></p>
<p><img src="http://www.fqxyi.com/images/Blog/avatar.jpg" alt="图像alt内容"><br><img src="http://www.fqxyi.com/images/Blog/avatar.jpg" alt="图像alt内容" title="图像title"></p>
<p><strong>非行内式</strong><br>同上</p>
<h4 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h4><p><strong>如果链接的地址和名称一样的时候，可以简写</strong></p>
<p><a href="http://www.baidu.com" target="_blank" rel="external">http://www.baidu.com</a></p>
<p><strong>相当于下面写法</strong></p>
<p><a href="http://www.baidu.com" target="_blank" rel="external">http://www.baidu.com</a></p>
<h4 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h4><p><strong>以下字符，要在前面插入反斜杠\，才能将字符原样输出</strong></p>
<p>\   反斜线</p>
<p>`   反引号</p>
<p>*   星号</p>
<p>_   底线</p>
<p>{}  花括号</p>
<p>[]  方括号</p>
<p>()  括弧</p>
<p>#   井字号</p>
<p>+   加号</p>
<p>-   减号</p>
<p>.   英文句点</p>
<p>!   惊叹号</p>
<h4 id="表格"><a href="#表格" class="headerlink" title="表格???"></a>表格???</h4><p><strong>表格是github风格独有的语法</strong></p>
<p><strong>第一行的表格头部可以没有，但是第二行必须有。第二行的冒号代表居左居中还是居右；不加冒号，默认居左</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">item</th>
<th style="text-align:right">value</th>
<th style="text-align:center">qty</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a</td>
<td style="text-align:right">1</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:left">b</td>
<td style="text-align:right">2</td>
<td style="text-align:center">6</td>
</tr>
</tbody>
</table>
<p><strong>或者用html标签来构造表格</strong>  </p>
<pre><code>&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;Item&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;Value&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;Qty&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Computer&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;$1600&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Phone&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;$12&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Pipe&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;$1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;234&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</code></pre><h4 id="html代码"><a href="#html代码" class="headerlink" title="html代码"></a>html代码</h4><p><strong>当html代码前面没有四个空格，则会解析html代码；若有4个空格或者有三个单引号括着，则不解析代码，会直接显示代码</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;markdown是标记语言，通过标记语法使普通文本具有一定格式。&lt;/p&gt;
    
    </summary>
    
      <category term="Markdown标记语言" scheme="http://yoursite.com/categories/Markdown%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
</feed>
